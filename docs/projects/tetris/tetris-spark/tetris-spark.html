<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-06-07">

<title>Ian Convy’s Stuff - “Solving” Tetris with Apache Spark</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/quarto-contrib/bootstrap-icons-1.9.1/all.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Ian Convy’s Stuff</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../../projects/phd/phd.html" rel="" target="" aria-current="page">
 <span class="menu-text">PhD Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../projects/tetris/tetris.html" rel="" target="">
 <span class="menu-text">Tetris</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../projects/other/other.html" rel="" target="">
 <span class="menu-text">Other</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/IanConvy" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text">GitHub</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.linkedin.com/in/ian-convy" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text">LinkedIn</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../projects/tetris/tetris.html">Tetris</a></li><li class="breadcrumb-item"><a href="../../../projects/tetris/tetris-spark/tetris-spark.html">Solving Tetris with Spark</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../projects/phd/phd.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">PhD Research</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../projects/phd/decomp/deomp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Interaction Decomposition</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../projects/phd/bayesian/bayesian.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bayesian Error Correction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../projects/phd/mi-scaling/mi-scaling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Correlation Scaling in Images</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../projects/tetris/tetris.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tetris</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../projects/tetris/tetris-sql/tetris-sql.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">PostgreTETRIS</span></a>
  </div>
</li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../projects/tetris/tetris-vba/tetris-vba.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tetris in VBA</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../projects/tetris/tetris-vba/post-thoughts-tetris-vba.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Post: Some Thoughts on VBA Tetris</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../projects/tetris/tetris-spark/tetris-spark.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Solving Tetris with Spark</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../projects/tetris/tetris-emulator/tetris-emulator.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">NES Emulator</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../projects/other/other.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Other</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../projects/other/neoquest/neoquest.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Decoding NeoQuest II</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../projects/other/wavelet/wavelet.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Wavelet Reconstructor</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../projects/other/speedrunning/speedrunning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Speedrunning Report</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../projects/other/libraryofjuggling/libraryofjuggling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Library of Juggling</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#the-stacking-game" id="toc-the-stacking-game" class="nav-link" data-scroll-target="#the-stacking-game">The Stacking Game</a></li>
  <li><a href="#problem-complexity" id="toc-problem-complexity" class="nav-link" data-scroll-target="#problem-complexity">Problem Complexity</a></li>
  <li><a href="#description-of-the-algorithm" id="toc-description-of-the-algorithm" class="nav-link" data-scroll-target="#description-of-the-algorithm">Description of the Algorithm</a>
  <ul class="collapse">
  <li><a href="#computing-the-connections" id="toc-computing-the-connections" class="nav-link" data-scroll-target="#computing-the-connections">Computing the connections</a></li>
  <li><a href="#computing-the-averages" id="toc-computing-the-averages" class="nav-link" data-scroll-target="#computing-the-averages">Computing the averages</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">“Solving” Tetris with Apache Spark</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 7, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p><i class="bi-github " style="" role="img" aria-hidden="true"></i> <a href="https://github.com/IanConvy/solving-tetris-with-spark">GitHub Repository</a></p>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>This project implements an algorithm in Apache Spark that solves the stacking portion of Tetris for a specified board width. Since the piece order in Tetris is randomized, the challenge of stacking pieces lies in knowing what stack configuration can handle the widest variety of possible piece sequences before a hole is created in the stack. Starting from a given stack configuration, the algorithm uses recursion to compute the average number of pieces that a player will be able to place under optimal play before creating a hole. Once a table of these average values is computed, the optimal strategy is to always place the next piece such that the average for the new stack configuration is maximized.</p>
<p>The <code>walkthrough.ipynb</code> notebook in the GitHub repo (linked above) contains a description of the algorithm along with a sample calculation for a small Tetris board. The full source code is contained in the <code>analyze.py</code>, <code>generate.py</code>, and <code>play.py</code> Python modules, which can be run in the environment generated by <code>requirements.txt</code>.</p>
<p>A non-interactive version of the Jupyter notebook is reproduced below.</p>
</section>
<section id="the-stacking-game" class="level2">
<h2 class="anchored" data-anchor-id="the-stacking-game">The Stacking Game</h2>
<p>Tetris is arguably the most popular video game ever made, having seen countless releases on virtually every piece of computer hardware imaginable. The game was originally developed by Alexey Pajitnov in 1985, and requires the player to stack a set of falling pieces called “tetrominos” into a continuous tower, such that there are no gaps between the pieces. Points are scored by filling in an entire row of blocks, at which point those blocks are removed from the board and the height of the tower is reduced. The game ends when the player is unable to clear rows fast enough and allows the tower to reach the top of the board.</p>
<p>The challenge of Tetris comes from the shapes of the tetrominos, which consist of all seven polygons that can be built from four equally-sized square blocks. These pieces can be rotated and translated as they fall, with the player needing to interlock them together into a continuous stack in order to clear rows. Since the order of the pieces is random and unknown to the player, an optimal strategy must consider not only the placement of the current piece, but also how the next piece (and all subsequent pieces) can be incorporated into the tower. The overarching goal is to ensure that each piece fits with the previous pieces to form a continuous surface devoid of holes, so that rows can be cleared. This is the challenge that we wish to “solve” using an algorithm.</p>
<p>The word “solve” is presented here in quotes because our goal is not to find the optimal strategy in its entirety. Instead, we seek only an optimal strategy for stacking pieces until it is impossible to prevent a hole from forming somewhere in the tower. In a real game of Tetris this does not cause play to end, as there are ways of repairing these holes and continuing the stack. By focusing solely on continous piece stacking, we drastically reduce the complexity of the problem, making it possible to find strong solutions with reasonable computational resources.</p>
</section>
<section id="problem-complexity" class="level2">
<h2 class="anchored" data-anchor-id="problem-complexity">Problem Complexity</h2>
<p>To pin down the overall complexity of this problem, we must define the height and width of the area where we are allowed to stack pieces (referred to as the <em>board</em>). In standard Tetris the board is 20 blocks high and 10 blocks across, but for maximum scoring it is common to initially leave the left-most column unfilled while stacking. This means that the maximum effective play area is 20 x 9, which can fit 21^9 = 794,280,046,581 differently-shaped piece stacks inside of it. In general, the number of possible stacks is given by (<em>height</em> + 1)^<em>width</em>, since each column can have a number of blocks in the range [0, <em>height</em>], and there are <em>width</em> distinct columns with their own independent configurations.</p>
<p>For each tower configuration, we will need to consider all of the possible ways that the tetrominos can be stacked on top without creating any holes. There is no simple formula for this quantity, as it is highly dependent on the specific contours of the stack. A more concrete quantity to consider is the maximum number of pieces that can be placed in a sequence. Since no piece can be placed when the board is completely full, and since each piece has four blocks, we can stack at most <em>height</em> * <em>width</em> / 4 pieces before completely running out of room. The full 20 x 9 board, for example, can have at most 45 pieces in any sequence, although most towers will terminate significantly earlier than this.</p>
</section>
<section id="description-of-the-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="description-of-the-algorithm">Description of the Algorithm</h2>
<p>Since Tetris is a game with incomplete information (the sequence of pieces), we will seek a strategy that maximizes the average performance over all sequences. Our measure of performance will be the number of pieces stacked before a hole is formed, with an optimal strategy maximizing this number. Such a strategy can be found via recursion by computing a set of sequence-limited averages, up to the maximum number that can fit on the board. The optimal strategy is then to place each piece such that you end up with a tower configuration that has the highest expected stack length, conditioned on the remaining number of pieces that can be stacked before filling the board.</p>
<p>To compute the required set of averages, we can follow an algorithm with the following steps for each tower configuration:</p>
<ol type="1">
<li>Compute the valid placements for all seven tetrominos, taking into account every possible translation and rotation.</li>
<li>Compute the probability that the next piece in the sequence will be possible to stack without creating a hole. This is the average number of placed pieces for a sequence of length 1.</li>
<li>For each piece type, find the tower configuration with the highest average computed in step 2 that can be reached by placing that piece type, and then compute a new average by taking the mean of these maximimal averages. This is the average number of placed pieces for a sequence of length 2.</li>
<li>Repeat step 3 <em>n</em> more times, maximizing the averages generated from the previous iteration in the cycle. This gives the average number of placed pieces for a sequence of length n + 2. The value of <em>n</em> should be chosen so that <em>n</em> - 2 is less than the maximum number of pieces that can fit on the board.</li>
</ol>
<p>Each portion of this algorithm can be carried out using the DataFrame API in Apache Spark.</p>
<section id="computing-the-connections" class="level3">
<h3 class="anchored" data-anchor-id="computing-the-connections">Computing the connections</h3>
<p>For step 1 of the algorithm, we need to compute all of the different ways that a starting tower configuration can transition to a different configuration after placing a piece. To do this, we start by defining two different ways to represent a Tetris board. Since we are only interested in towers without holes, we can describe each configuration uniquely by listing out the height of each column. This array-based representation can be compressed into a single integer (which we will call the <em>board id</em>) by adding together powers of the board height. For a standard height of 20, we construct an integer that is 21^0 = 1 times the height of the first column, 21^1 = 21 times the height of the second column, 21^2 = 441 times the height of the third column, and so on. This ensures that each board has a single unique integer that represents it. The code which converts between these two representations is given below.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_board_columns(board_id, height, width):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    board <span class="op">=</span> []</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, width <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        height_power <span class="op">=</span> (height <span class="op">+</span> <span class="dv">1</span>)<span class="op">**</span>(x <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        shift_to_ones <span class="op">=</span> math.floor(board_id <span class="op">/</span> height_power)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        digit <span class="op">=</span> shift_to_ones <span class="op">%</span> (height <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        board.append(digit)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> board</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_board_id(board, height):</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    width <span class="op">=</span> <span class="bu">len</span>(board)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    board_id <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, width <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        power <span class="op">=</span> (height <span class="op">+</span> <span class="dv">1</span>)<span class="op">**</span>(x <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        board_id <span class="op">+=</span> board[x <span class="op">-</span> <span class="dv">1</span>]<span class="op">*</span>power</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> board_id</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>test_id <span class="op">=</span> <span class="dv">145672560876</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>test_board <span class="op">=</span> get_board_columns(test_id, <span class="dv">20</span>, <span class="dv">9</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>inverted_id <span class="op">=</span> get_board_id(test_board, <span class="dv">20</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Map id to columns and then back to id: </span><span class="sc">{</span>test_id<span class="sc">}</span><span class="ss"> -&gt; </span><span class="sc">{</span>test_board<span class="sc">}</span><span class="ss"> -&gt; </span><span class="sc">{</span>inverted_id<span class="sc">}</span><span class="ss">."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Map id to columns and then back to id: 145672560876 -&gt; [3, 6, 8, 7, 4, 10, 18, 17, 3] -&gt; 145672560876.</code></pre>
<p>Note that the two representations are useful in different situations: the board id works great as a unique key to specify a given board, but is very difficult to visualize. The column heights, by contrast, are more verbose but somewhat easier to understand at a glance.</p>
<p>To compute the different connections between tower configurations, we will start with a Spark DataFrame that is populated with all possible board ids using the <code>range</code> function. Each row will then be expanded into its height-based representation using a set of column functions that mimic <code>get_board_columns</code> from the previous code block. To determine where pieces can be placed without creating holes, we must match the contour of the tower with the bottom of the piece. The possible contours for each of the seven tetrominos are returned by the following function:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_piece_maps():</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    pieces <span class="op">=</span> {}</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    pieces[<span class="st">"i"</span>] <span class="op">=</span> [([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>]), ([], [<span class="dv">4</span>])]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    pieces[<span class="st">"t"</span>] <span class="op">=</span> [([<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>]), ([<span class="op">-</span><span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">3</span>]), ([<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>]), ([<span class="dv">1</span>], [<span class="dv">3</span>, <span class="dv">1</span>])]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    pieces[<span class="st">"sq"</span>] <span class="op">=</span> [([<span class="dv">0</span>], [<span class="dv">2</span>, <span class="dv">2</span>])]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    pieces[<span class="st">"zr"</span>] <span class="op">=</span> [([<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>]), ([<span class="op">-</span><span class="dv">1</span>], [<span class="dv">2</span>, <span class="dv">2</span>])]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    pieces[<span class="st">"zl"</span>] <span class="op">=</span> [([<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>]), ([<span class="dv">1</span>], [<span class="dv">2</span>, <span class="dv">2</span>])]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    pieces[<span class="st">"lr"</span>] <span class="op">=</span> [([<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>]), ([<span class="op">-</span><span class="dv">2</span>], [<span class="dv">1</span>, <span class="dv">3</span>]), ([<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>]), ([<span class="dv">0</span>], [<span class="dv">3</span>, <span class="dv">1</span>])]</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    pieces[<span class="st">"ll"</span>] <span class="op">=</span> [([<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>]), ([<span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">3</span>]), ([<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>]), ([<span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">1</span>])]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pieces</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Each piece is represented by a pair of tuples, with the first tuple containing the relative changes in column height that are needed (for each of the possible piece orientations) in order to place the piece without creating any holes. By looping through all positions, we can compute all valid placements and thus all connections to other tower configurations. The following code shows a Spark routine that will carry out these calculations for an arbitrary height and width (resources permitting):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyspark.sql.functions <span class="im">as</span> sfn</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyspark.sql.types <span class="im">as</span> stype</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> src <span class="im">import</span> analyze</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_connections(height, width, spark_session):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ths function finds all mappings from one tower configuration to</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># another that occur when placing a Tetris piece. The resulting table</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># has columns "id", "new_id", and "piece", with "new_id" being the tower</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># configuration that can be reached by adding "piece" to the board represented</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># by "id".</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    max_id <span class="op">=</span> (height <span class="op">+</span> <span class="dv">1</span>)<span class="op">**</span>width </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    ids <span class="op">=</span> spark_session.<span class="bu">range</span>(max_id) <span class="co"># DataFrame populated by all possible board ids </span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    all_cols <span class="op">=</span> get_board_columns(height, width)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    boards <span class="op">=</span> ids.withColumns(all_cols) <span class="co"># Dataframe now has board heights as well as ids</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    schema <span class="op">=</span> stype.StructType([</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        stype.StructField(<span class="st">"id"</span>, stype.LongType(), <span class="va">False</span>), </span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        stype.StructField(<span class="st">"new_id"</span>, stype.LongType(), <span class="va">True</span>), </span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        stype.StructField(<span class="st">"piece"</span>, stype.StringType(), <span class="va">False</span>)])</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    all_connections <span class="op">=</span> spark_session.createDataFrame([], schema <span class="op">=</span> schema) <span class="co"># Empty dataframe that will be iteratively updated</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (piece_name, maps) <span class="kw">in</span> analyze.pieces.items():</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (surface, piece_heights) <span class="kw">in</span> maps:</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>            piece_width <span class="op">=</span> <span class="bu">len</span>(piece_heights)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> piece_width <span class="op">&lt;=</span> width: <span class="co"># Pieces wider than the board cannot be placed</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> pos <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, width <span class="op">-</span> piece_width <span class="op">+</span> <span class="dv">2</span>): <span class="co"># Iterate over all positions that the piece can be stacked at</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>                    col_list <span class="op">=</span> [sfn.col(<span class="ss">f"</span><span class="sc">{</span>x <span class="op">+</span> pos<span class="sc">}</span><span class="ss">"</span>) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(piece_width)] <span class="co"># List columns that are intersected by piece</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>                    diff_list <span class="op">=</span> [col_2 <span class="op">-</span> col_1 <span class="cf">for</span> (col_1, col_2) <span class="kw">in</span> <span class="bu">zip</span>(col_list[:<span class="op">-</span><span class="dv">1</span>], col_list[<span class="dv">1</span>:])] <span class="co"># Get relative heights of columns</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>                    board_surfaces <span class="op">=</span> boards.select(<span class="st">"*"</span>, <span class="op">*</span>diff_list)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>                    matched_boards <span class="op">=</span> board_surfaces</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> (col, diff) <span class="kw">in</span> <span class="bu">zip</span>(diff_list, surface):</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>                        matched_boards <span class="op">=</span> matched_boards.<span class="bu">filter</span>(col <span class="op">==</span> diff) <span class="co"># Piece can only be placed if it exactly matches the tower surface</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>                    raised_cols <span class="op">=</span> {<span class="ss">f"</span><span class="sc">{</span>x <span class="op">+</span> pos<span class="sc">}</span><span class="ss">"</span>:(col <span class="op">+</span> added) <span class="cf">for</span> (x, (col, added)) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(col_list, piece_heights))}</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>                    raised_boards <span class="op">=</span> matched_boards.select(<span class="op">*</span>boards.columns).withColumns(raised_cols) <span class="co"># Generate new board after adding piece</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>                    valid_boards <span class="op">=</span> raised_boards</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> col <span class="kw">in</span> col_list:</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>                        valid_boards <span class="op">=</span> valid_boards.<span class="bu">filter</span>(col <span class="op">&lt;=</span> height) <span class="co"># Remove tower configuration that are too tall</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>                    new_id_col <span class="op">=</span> get_board_id(height, width)</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>                    connections <span class="op">=</span> valid_boards.select(<span class="st">"id"</span>, new_id_col.alias(<span class="st">"new_id"</span>), sfn.lit(piece_name).alias(<span class="st">"piece"</span>))</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>                    all_connections <span class="op">=</span> all_connections.union(connections)</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> all_connections</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This function assembles the full connections table out of subtables corresponding to each piece and placement position. While the number of tower configurations and thus connections will scale exponentially with the board width, the operations themselves are all narrow and can be done in a distributed manner without any shuffle operations.</p>
</section>
<section id="computing-the-averages" class="level3">
<h3 class="anchored" data-anchor-id="computing-the-averages">Computing the averages</h3>
<p>After the connections are tabulated, the rest of the algorithm focuses on computing the average number of pieces that can be placed before the formation of a hole is unavoidable. Since our goal is to choose a strategy that maximizes this average, we will want to stack pieces such that we always move to a new configuration that itself has a high average. For a finite number of pieces, we can always construct an algorithm that starts with a piece sequence of length one and then recursively computes optimal averages for a sequence of length <em>n</em> using results from length <em>n -1</em>. The key observation is that the <em>n</em>th optimal average is just one plus a weighted sum of the <em>n-1</em> averages maximized with respect to each of the seven possible pieces. The code for this portion of the algorithm is given below:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyspark.sql.functions <span class="im">as</span> sfn</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_avgs(height, width, spark_session):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This function uses the connection table created by generate_connections</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># to compute the average number of successful piece placements before a hole</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># is formed. This average is calculated with respect to optimal piece placement,</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># which is enforced via a recursive algorithm.</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    all_connections <span class="op">=</span> spark_session.read.<span class="bu">format</span>(<span class="st">"parquet"</span>).load(<span class="st">"connection_path"</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    ids <span class="op">=</span> spark_session.<span class="bu">range</span>((height <span class="op">+</span> <span class="dv">1</span>)<span class="op">**</span>width)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    avgs <span class="op">=</span> old_avgs <span class="op">=</span> ids.withColumn(<span class="st">"avg"</span>, sfn.lit(<span class="fl">0.0</span>)) <span class="co"># This is the "average" for a piece sequence of length 0</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    max_depth <span class="op">=</span> <span class="bu">int</span>(height<span class="op">*</span>width <span class="op">/</span> <span class="dv">4</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> depth <span class="kw">in</span> <span class="bu">range</span>(max_depth <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> depth <span class="op">&gt;</span> <span class="dv">0</span>: <span class="co"># Iterations greater than length 0 are generated from previously-saved results</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            avgs.write.<span class="bu">format</span>(<span class="st">"parquet"</span>).save(<span class="ss">f"</span><span class="sc">{</span>width<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>height<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>depth<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            old_avgs <span class="op">=</span> spark_session.read.<span class="bu">format</span>(<span class="st">"parquet"</span>).load(<span class="ss">f"</span><span class="sc">{</span>width<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>height<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>depth<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Depth: </span><span class="sc">{</span>depth<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The first step of the algorithm is to append the previous averages for each "new_id" column in the connections table</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        connection_avgs <span class="op">=</span> all_connections.alias(<span class="st">"c"</span>).join(old_avgs.alias(<span class="st">"a"</span>), sfn.col(<span class="st">"c.new_id"</span>) <span class="op">==</span> sfn.col(<span class="st">"a.id"</span>), <span class="st">"left"</span>)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        connection_avgs <span class="op">=</span> connection_avgs.select(<span class="st">"c.id"</span>, <span class="st">"c.piece"</span>, <span class="st">"a.avg"</span>).fillna(<span class="fl">0.0</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Then, the maximum avg is chosen for each starting configuration and piece</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        best_choice <span class="op">=</span> connection_avgs.groupBy(<span class="st">"id"</span>, <span class="st">"piece"</span>).agg(sfn.<span class="bu">max</span>(<span class="st">"avg"</span>).alias(<span class="st">"max_avg"</span>))</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Finally, a weighted average of one plus the previous max averages is computed</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        avgs <span class="op">=</span> best_choice.select(<span class="st">"id"</span>, (<span class="dv">1</span><span class="op">/</span><span class="dv">7</span> <span class="op">+</span> sfn.col(<span class="st">"max_avg"</span>)<span class="op">/</span><span class="dv">7</span>).alias(<span class="st">"max_avg"</span>)).groupBy(<span class="st">"id"</span>).agg(sfn.<span class="bu">sum</span>(<span class="st">"max_avg"</span>).alias(<span class="st">"avg"</span>))</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        depth <span class="op">+=</span><span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Unlike the connection algorithm from the previous section, the Spark operations here involve join and aggregation functions that require shuffling of the partition data. This is fundamentally unavoidable, as the data cannot be partitioned in a way that is efficient for both the extraction of previous averages (the join) and computation of the optimal piece placement (the aggregation) simultaneously.</p>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>A single computer can comfortably compute results for a board width of around 6, but for simplicity we will look at a smaller playfield that is only 4 blocks wide. To validate the results of the algorithm, we can play a large number of Tetris games and compare the observed mean sequence length with the predicted length. This is implemented in the following code from <code>play.py</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyspark.sql <span class="im">as</span> sql</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyspark.sql.functions <span class="im">as</span> sfn</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> src <span class="im">import</span> analyze</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Avgs():</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This class handles the retrieval of averages from the tables computed</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># in generate.py.</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, spark, height, width, memory <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The class can operate in memory mode if the number of tower configurations is</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># small enough, or it can read data directly from the parquet files.</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        num_pieces <span class="op">=</span> <span class="bu">int</span>(height<span class="op">*</span>width <span class="op">/</span> <span class="dv">4</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.board_avgs <span class="op">=</span> spark.read.<span class="bu">format</span>(<span class="st">"parquet"</span>).load(<span class="ss">f"example_data/avgs_20-4"</span>)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> memory:</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.board_dict <span class="op">=</span> {row.asDict()[<span class="st">"id"</span>]:row.asDict()[<span class="st">"avg"</span>] <span class="cf">for</span> row <span class="kw">in</span> <span class="va">self</span>.board_avgs.toLocalIterator()}</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.memory <span class="op">=</span> memory</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get(<span class="va">self</span>, board_id):</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.memory:</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>            avg <span class="op">=</span> <span class="bu">float</span>(<span class="va">self</span>.board_dict.get(<span class="bu">int</span>(board_id), <span class="dv">0</span>))</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>            rows <span class="op">=</span> <span class="va">self</span>.board_avgs.<span class="bu">filter</span>(sfn.col(<span class="st">"id"</span>) <span class="op">==</span> board_id).select(<span class="st">"avg"</span>).collect()</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>            avg <span class="op">=</span> rows[<span class="dv">0</span>].asDict()[<span class="st">"avg"</span>] <span class="cf">if</span> rows <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> avg</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> play_game(start_board, height, num_moves, avgs):</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This function plays a game of Tetris using the</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># provided starting configuration, height, and number</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># of moves. For each piece, the placement with the</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># highest average is chosen.</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    board <span class="op">=</span> start_board</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    moves <span class="op">=</span> [start_board]</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_moves, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>        piece <span class="op">=</span> random.choice(<span class="bu">list</span>(analyze.pieces.keys()))</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>        connections <span class="op">=</span> analyze.get_connections(board, height)</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>        choices <span class="op">=</span> []</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> board <span class="kw">in</span> connections[piece]:</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>            board_id <span class="op">=</span> analyze.get_board_id(board, height)</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>            avg <span class="op">=</span> avgs.get(<span class="bu">str</span>(board_id))</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>            choices.append((board, avg))</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(choices) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>        board <span class="op">=</span> <span class="bu">max</span>(choices, key <span class="op">=</span> <span class="kw">lambda</span> tupl:tupl[<span class="dv">1</span>])[<span class="dv">0</span>]</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>        moves.append(board)</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> moves</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multiple_runs(runs, start_board, height, num_pieces, avgs):</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This function plays a given number of Tetris games using the</span></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># specified parameters, and then prints the theoretical average,</span></span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># observed average, and best performance.</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>    expected <span class="op">=</span> avgs.get(analyze.get_board_id(start_board, height))</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>    move_lists <span class="op">=</span> []</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> game <span class="kw">in</span> <span class="bu">range</span>(runs):</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>        moves <span class="op">=</span> play_game(start_board, height, num_pieces, avgs)</span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>        move_lists.append(moves)</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\r</span><span class="ss">Game </span><span class="sc">{</span>game <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> / </span><span class="sc">{</span>runs<span class="sc">}</span><span class="ss">"</span>, end <span class="op">=</span> <span class="st">""</span>)</span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>    totals <span class="op">=</span> [<span class="bu">len</span>(moves[<span class="dv">1</span>:]) <span class="cf">for</span> moves <span class="kw">in</span> move_lists]</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">""</span>)</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Exp: </span><span class="sc">{</span>expected<span class="sc">:.4f}</span><span class="ss"> | Avg: </span><span class="sc">{</span><span class="bu">sum</span>(totals) <span class="op">/</span> runs<span class="sc">:.4f}</span><span class="ss"> | Best:</span><span class="sc">{</span><span class="bu">max</span>(totals)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> move_lists</span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>board <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>runs <span class="op">=</span> <span class="bu">int</span>(<span class="fl">1e5</span>)</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>num_pieces <span class="op">=</span> <span class="bu">int</span>(height<span class="op">*</span>width <span class="op">/</span> <span class="dv">4</span>)</span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a>spark <span class="op">=</span> sql.SparkSession.builder.config(<span class="st">"spark.driver.memory"</span>, <span class="st">"15g"</span>).config(<span class="st">'spark.ui.showConsoleProgress'</span>, <span class="va">False</span>).getOrCreate()</span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>avgs <span class="op">=</span> Avgs(spark, height, width, memory <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>start_board <span class="op">=</span> analyze.get_board_columns(board, height, width)</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>runs <span class="op">=</span> multiple_runs(runs, start_board, height, num_pieces, avgs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>